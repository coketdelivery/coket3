<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <!-- ëª¨ë°”ì¼ ì „ìš©: í™•ëŒ€/ì¶•ì†Œ ë¶ˆê°€ -->
  <meta name="viewport" content="width=device-width, maximum-scale=1.0, user-scalable=no">
  <title>Tetris - Touch Optimized</title>
  <style>
    /* ë¶ˆí•„ìš”í•œ UI ì œê±°, ì „ì²´ í™”ë©´ ì‚¬ìš© */
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
    }
    /* ìº”ë²„ìŠ¤ëŠ” ì „ì²´ ì°½ í¬ê¸°ë¡œ ì„¤ì • (JSì—ì„œ ë™ì  ì¡°ì •) */
    #gameCanvas {
      display: block;
      touch-action: none;
    }
    /* ì ìˆ˜ì™€ ì‹œê°„ì€ í•„ìš” ì‹œ í™”ë©´ í•˜ë‹¨ì— ë°°ì¹˜ (ì„ íƒì‚¬í•­) */
    #scoreBoard, #timeBoard {
      position: absolute;
      color: white;
      font-size: 18px;
      top: 5px;
      left: 5px;
      margin: 0;
      padding: 5px;
      background: rgba(0,0,0,0.5);
      z-index: 2;
    }
    #timeBoard {
      top: 35px;
    }
    /* ê²Œì„ ì‹œì‘ ì „ ì˜¤ë²„ë ˆì´ ìŠ¤íƒ€ì¼ */
    #startScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      color: white;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }
    #startScreen h1 {
      font-size: 48px;
      margin-bottom: 20px;
    }
    #startScreen button {
      font-size: 24px;
      padding: 10px 20px;
      cursor: pointer;
      background-color: #ff6666; 
      color: #fff;
      border: none;
      border-radius: 8px;
    }

    /* (1) ê²Œì„ ì˜¤ë²„ ì˜¤ë²„ë ˆì´ ì¶”ê°€ */
    #gameOverScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      color: white;
      display: none;  /* ì²˜ìŒì—ëŠ” ìˆ¨ê¹€ */
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 20;
      text-align: center;
      padding: 20px;
    }
    #gameOverScreen p {
      font-size: 24px;
      margin: 10px 0;
    }
    #gameOverScreen button {
      font-size: 24px;
      padding: 10px 20px;
      cursor: pointer;
      background-color: #ff66cc; /* ê·€ì—¬ìš´ ëŠë‚Œ */
      color: #fff;
      border: none;
      border-radius: 10px;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <!-- ìº”ë²„ìŠ¤ -->
  <canvas id="gameCanvas"></canvas>
  
  <!-- ì ìˆ˜ì™€ ì‹œê°„ (ì›í•˜ëŠ” ê²½ìš° í‘œì‹œ) -->
  <div id="scoreBoard">Score: 0</div>
  <div id="timeBoard">Time: 0:00</div>
  
  <!-- ê²Œì„ ì‹œì‘ ì „ ì˜¤ë²„ë ˆì´ -->
  <div id="startScreen">
    <h1>ì½”ì¼“ë°°ì†¡ - í…ŒíŠ¸ë¦¬ìŠ¤</h1>
    <p>ìœ íŠœë¸Œ 'ê±¸ì½”_Gulko' ì €ì‘ê¶Œ ì½˜í…ì¸ ì…ë‹ˆë‹¤.<br>
    <p>Â© 2025 ì½”ì¼“ê²Œì„ì¦ˆ. All rights reserved.<br>
      <a href="https://www.youtube.com/@Gulko" target="_blank">https://www.youtube.com/@Gulko</a></p>
    <button id="startButton">ê²Œì„ì‹œì‘</button>
  </div>

  <!-- (1) ê²Œì„ ì˜¤ë²„ ì˜¤ë²„ë ˆì´ ì¶”ê°€ -->
  <div id="gameOverScreen">
    <p>ê²Œì„ ì˜¤ë²„! ğŸ˜¢</p>
    <p>ì½”íŒ¡ êµ¬ì…ì€ ê±¸ì½”ì™€ í•¨ê»˜<br>
       <a href="https://www.youtube.com/@Gulko" target="_blank">https://www.youtube.com/@Gulko</a><br>
       ì‚¬ë‘í•©ë‹ˆë‹¤. ê³ ê°ë‹˜.</p>
    <button id="restartButton">ë‹¤ì‹œ ì‹œì‘í•˜ê¸°</button>
  </div>

  <!-- ì˜¤ë””ì˜¤ íŒŒì¼ë“¤ (ì‚¬ìš© íŒŒì¼ì— ë§ê²Œ ìˆ˜ì •) -->
  <audio id="blockDropSound" src="drop_sound.mp3"></audio>
  <audio id="lineClearSound" src="clear_sound.mp3"></audio>
  <audio id="blockBottomSound" src="block_bottom.mp3"></audio>
  <audio id="levelUpSound" src="levelup_sound.mp3"></audio>
  <audio id="bgMusic" src="bg_music.mp3" loop></audio>
  
  <script>
    // DOM ìš”ì†Œë“¤
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreBoard = document.getElementById('scoreBoard');
    const timeBoard = document.getElementById('timeBoard');
    const blockDropSound = document.getElementById('blockDropSound');
    const lineClearSound = document.getElementById('lineClearSound');
    const blockBottomSound = document.getElementById('blockBottomSound');
    const levelUpSound = document.getElementById('levelUpSound');
    const bgMusic = document.getElementById('bgMusic');
    const startScreen = document.getElementById('startScreen');
    const startButton = document.getElementById('startButton');
    
    // (1) ê²Œì„ ì˜¤ë²„ ì˜¤ë²„ë ˆì´ DOM
    const gameOverScreen = document.getElementById('gameOverScreen');
    const restartButton = document.getElementById('restartButton');

    // ë°°ê²½ ì´ë¯¸ì§€ (íŒŒì¼ëª…/ê²½ë¡œ ìˆ˜ì •)
    const backgroundImg = new Image();
    backgroundImg.src = 'background.jpg';
    
    // ê²Œì„ ë³´ë“œ ì„¤ì •
    const ROWS = 20, COLS = 10;
    let BLOCK_SIZE; // ìº”ë²„ìŠ¤ í¬ê¸°ì— ë”°ë¼ ë™ì  ê³„ì‚°
    let offsetX = 0, offsetY = 0;  // ë³´ë“œë¥¼ ìº”ë²„ìŠ¤ ì¤‘ì•™ì— í‘œì‹œí•˜ê¸° ìœ„í•œ ì˜¤í”„ì…‹
    let board = [];
    function initBoard() {
      board = [];
      for (let r = 0; r < ROWS; r++) {
        board[r] = new Array(COLS).fill(0);
      }
    }
    
    // í…ŒíŠ¸ë¡œë¯¸ë…¸ íƒ€ì… ë° ì´ë¯¸ì§€
    const blockTypes = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
    const blockImages = {};
    blockTypes.forEach(type => {
      const img = new Image();
      img.src = type.toLowerCase() + '_block.png';
      blockImages[type] = img;
    });
    
    // í…ŒíŠ¸ë¡œë¯¸ë…¸ ëª¨ì–‘ ì •ì˜
    const shapes = {
      'I': [[1,1,1,1]],
      'O': [[1,1],[1,1]],
      'T': [[0,1,0],[1,1,1]],
      'S': [[0,1,1],[1,1,0]],
      'Z': [[1,1,0],[0,1,1]],
      'J': [[1,0,0],[1,1,1]],
      'L': [[0,0,1],[1,1,1]]
    };
    
    // 'Bag' ì•Œê³ ë¦¬ì¦˜ (ë™ì¼ ë¸”ë¡ ì—°ì† ë°©ì§€)
    let blockBag = [];
    function refillBag() {
      blockBag = [...blockTypes];
      for (let i = blockBag.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [blockBag[i], blockBag[j]] = [blockBag[j], blockBag[i]];
      }
    }
    
    // í˜„ì¬ ë–¨ì–´ì§€ëŠ” ë¸”ë¡ ì •ë³´
    let currentBlock = { type: null, shape: null, x: 0, y: 0 };
    function spawnBlock() {
      if (blockBag.length === 0) {
        refillBag();
      }
      currentBlock.type = blockBag.pop();
      currentBlock.shape = shapes[currentBlock.type] || [[1]];
      currentBlock.x = Math.floor((COLS - currentBlock.shape[0].length) / 2);
      currentBlock.y = 0;
      if (collision(currentBlock.x, currentBlock.y, currentBlock.shape)) {
        gameOver();
      }
    }
    
    // ì¶©ëŒ ê²€ì‚¬: ë³´ë“œ ê²½ê³„ì™€ ê³ ì • ë¸”ë¡ê³¼ì˜ ì¶©ëŒ í™•ì¸
    function collision(newX, newY, newShape) {
      for (let r = 0; r < newShape.length; r++) {
        for (let c = 0; c < newShape[r].length; c++) {
          if (newShape[r][c]) {
            const boardX = newX + c;
            const boardY = newY + r;
            if (boardX < 0 || boardX >= COLS || boardY >= ROWS) return true;
            if (boardY >= 0 && board[boardY][boardX]) return true;
          }
        }
      }
      return false;
    }
    
    // ë¸”ë¡ì„ ë³´ë“œì— ê³ ì • ë° ì¤„ ì‚­ì œ
    function fixBlock() {
      const shape = currentBlock.shape;
      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[r].length; c++) {
          if (shape[r][c]) {
            const boardX = currentBlock.x + c;
            const boardY = currentBlock.y + r;
            if (boardY >= 0 && boardY < ROWS && boardX >= 0 && boardX < COLS) {
              board[boardY][boardX] = currentBlock.type;
            }
          }
        }
      }
      checkLineClear();
    }
    
    // ì¤„ ì‚­ì œ ë° ì ìˆ˜ ì—…ë°ì´íŠ¸
    let score = 0;
    function checkLineClear() {
      let linesCleared = 0;
      for (let r = 0; r < ROWS; r++) {
        if (board[r].every(cell => cell !== 0)) {
          board.splice(r, 1);
          board.unshift(new Array(COLS).fill(0));
          score += 100;
          linesCleared++;
        }
      }
      if (linesCleared > 0) {
        lineClearSound.play().catch(() => {});
      }
    }
    
    // ë¸”ë¡ í•œ ì¹¸ ì•„ë˜ ì´ë™
    function moveBlockDown() {
      if (!collision(currentBlock.x, currentBlock.y + 1, currentBlock.shape)) {
        currentBlock.y++;
        blockDropSound.play().catch(() => {});
      } else {
        blockBottomSound.play().catch(() => {});
        fixBlock();
        spawnBlock();
      }
    }
    
    // ë‹¨ì¼ íƒ­: íšŒì „ (íšŒì „ í›„ ì¶©ëŒì´ ì—†ë‹¤ë©´)
    function rotateBlock() {
      const rotated = rotateMatrix(currentBlock.shape);
      if (!collision(currentBlock.x, currentBlock.y, rotated)) {
        currentBlock.shape = rotated;
      }
    }
    
    // í–‰ë ¬ íšŒì „ (ì‹œê³„ë°©í–¥)
    function rotateMatrix(matrix) {
      const result = [];
      for (let c = 0; c < matrix[0].length; c++) {
        const newRow = [];
        for (let r = matrix.length - 1; r >= 0; r--) {
          newRow.push(matrix[r][c]);
        }
        result.push(newRow);
      }
      return result;
    }
    
    // ë³´ë“œ ë° í˜„ì¬ ë¸”ë¡ ê·¸ë¦¬ê¸° (ë°°ê²½ ì´ë¯¸ì§€ í¬í•¨, ì¤‘ì•™ ì •ë ¬)
    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height);
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (board[r][c]) {
            const x = offsetX + c * BLOCK_SIZE;
            const y = offsetY + r * BLOCK_SIZE;
            ctx.drawImage(blockImages[board[r][c]], x, y, BLOCK_SIZE, BLOCK_SIZE);
            ctx.strokeStyle = "#fff";
            ctx.strokeRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
          }
        }
      }
    }
    
    function drawCurrentBlock() {
      const shape = currentBlock.shape;
      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[r].length; c++) {
          if (shape[r][c]) {
            const x = offsetX + (currentBlock.x + c) * BLOCK_SIZE;
            const y = offsetY + (currentBlock.y + r) * BLOCK_SIZE;
            ctx.drawImage(blockImages[currentBlock.type], x, y, BLOCK_SIZE, BLOCK_SIZE);
            ctx.strokeStyle = "#fff";
            ctx.strokeRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
          }
        }
      }
    }
    
    function draw() {
      drawBoard();
      drawCurrentBlock();
    }
    
    // ë©”ì¸ ê²Œì„ ë£¨í”„
    function gameLoop() {
      moveBlockDown();
      updateDifficulty();
      updateScoreAndTime();
      draw();
    }
    
    // ë‚œì´ë„ ì¡°ì ˆ: 30ì´ˆë§ˆë‹¤ ë ˆë²¨ ì¦ê°€, ì†ë„ 200msì”© ë¹¨ë¼ì§
    let gameSpeed = 1000;
    let levelTimer = Date.now();
    let level = 1;
    let startTime;
    let gameInterval;
    function updateDifficulty() {
      const elapsed = Date.now() - levelTimer;
      if (elapsed >= 30000) {
        gameSpeed = Math.max(200, gameSpeed - 200);
        level++;
        // ë ˆë²¨ì—… íš¨ê³¼(sound ë“± ì¶”ê°€ ê°€ëŠ¥)
        clearInterval(gameInterval);
        gameInterval = setInterval(gameLoop, gameSpeed);
        levelTimer = Date.now();
      }
    }
    
    // ì ìˆ˜ ë° ì‹œê°„ ì—…ë°ì´íŠ¸
    function updateScoreAndTime() {
      scoreBoard.textContent = "Score: " + score;
      const totalSeconds = Math.floor((Date.now() - startTime) / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      timeBoard.textContent = "Time: " + minutes + ":" + (seconds < 10 ? "0" : "") + seconds;
    }
    
    // ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ ì „ì²´ í™”ë©´ì— ë§ê²Œ ì¡°ì •, BLOCK_SIZE ë° ë³´ë“œ ì˜¤í”„ì…‹ ê³„ì‚°
    function updateCanvasSize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      // ê°€ë¡œì™€ ì„¸ë¡œ í¬ê¸° ëª¨ë‘ ê³ ë ¤í•˜ì—¬ BLOCK_SIZE ê²°ì •
      BLOCK_SIZE = Math.min(canvas.width / COLS, canvas.height / ROWS);
      offsetX = (canvas.width - BLOCK_SIZE * COLS) / 2;
      offsetY = (canvas.height - BLOCK_SIZE * ROWS) / 2;
    }
    
    // (2) gameOver() í•¨ìˆ˜ ìˆ˜ì •
    function gameOver() {
      clearInterval(gameInterval);
      // ê²Œì„ ì˜¤ë²„ í™”ë©´ì„ í‘œì‹œí•˜ê³ , ë°°ê²½ìŒì•… ì¤‘ë‹¨
      bgMusic.pause();
      gameOverScreen.style.display = 'flex'; 
    }
    
    // í„°ì¹˜ ì´ë²¤íŠ¸ ì²˜ë¦¬: í„°ì¹˜ ì‹œì‘, ì´ë™, ì¢…ë£Œë¥¼ í†µí•´ ë¸”ë¡ ì¡°ì‘
    let touchStartX = 0, touchStartY = 0;
    let accumulatedDeltaX = 0, accumulatedDeltaY = 0;
    let swipeThreshold = 20;
    
    canvas.addEventListener('touchstart', e => {
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      accumulatedDeltaX = 0;
      accumulatedDeltaY = 0;
      e.preventDefault();
    });
    
    canvas.addEventListener('touchmove', e => {
      const touch = e.touches[0];
      const deltaX = touch.clientX - touchStartX;
      const deltaY = touch.clientY - touchStartY;
      accumulatedDeltaX += deltaX;
      accumulatedDeltaY += deltaY;
      
      // ìˆ˜í‰ ì´ë™ ì²˜ë¦¬: ì„ê³„ê°’ì„ ì´ˆê³¼í•  ê²½ìš° í•œ ì¹¸ì”© ì´ë™
      while (Math.abs(accumulatedDeltaX) >= swipeThreshold) {
        if (accumulatedDeltaX > 0) {
          if (!collision(currentBlock.x + 1, currentBlock.y, currentBlock.shape))
            currentBlock.x++;
          accumulatedDeltaX -= swipeThreshold;
        } else {
          if (!collision(currentBlock.x - 1, currentBlock.y, currentBlock.shape))
            currentBlock.x--;
          accumulatedDeltaX += swipeThreshold;
        }
      }
      
      // ìˆ˜ì§ ì´ë™ ì²˜ë¦¬: ì•„ë˜ ë°©í–¥ìœ¼ë¡œ ì´ë™ ì‹œ í•œ ì¹¸ ì´ë™ (ìœ„ìª½ì€ ë¬´ì‹œ)
      while (Math.abs(accumulatedDeltaY) >= swipeThreshold) {
        if (accumulatedDeltaY > 0) {
          moveBlockDown();
          accumulatedDeltaY -= swipeThreshold;
        } else {
          accumulatedDeltaY += swipeThreshold;
        }
      }
      
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      
      draw();
      e.preventDefault();
    });
    
    canvas.addEventListener('touchend', e => {
      let touchEndX = e.changedTouches[0].clientX;
      let touchEndY = e.changedTouches[0].clientY;
      const deltaX = touchEndX - touchStartX;
      const deltaY = touchEndY - touchStartY;
      
      if (Math.abs(deltaX) < swipeThreshold && Math.abs(deltaY) < swipeThreshold) {
        rotateBlock();
      }
      draw();
      e.preventDefault();
    });
    
    // ì°½ í¬ê¸° ë³€í™” ê°ì§€ ì‹œ ìº”ë²„ìŠ¤ ë° ì˜¤í”„ì…‹ ì—…ë°ì´íŠ¸
    window.addEventListener('resize', () => {
      updateCanvasSize();
      draw();
    });
    updateCanvasSize();
    
    // ê²Œì„ ì‹œì‘ í”Œë˜ê·¸
    let gameStarted = false;
    
    // ê²Œì„ ì´ˆê¸°í™” ë° ì‹œì‘ í•¨ìˆ˜
    function startGame() {
      updateCanvasSize();
      initBoard();
      refillBag();
      spawnBlock();
      score = 0;
      level = 1;
      gameSpeed = 1000;
      levelTimer = Date.now();
      startTime = Date.now();
      gameInterval = setInterval(gameLoop, gameSpeed);
      bgMusic.volume = 0.3;
      bgMusic.play().catch(() => {});
      gameStarted = true;
    }
    
    // ì‹œì‘ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸: ì˜¤ë²„ë ˆì´ ìˆ¨ê¸°ê³  ê²Œì„ ì‹œì‘
    startButton.addEventListener('click', () => {
      startScreen.style.display = 'none';
      startGame();
    });

    // (3) ì¬ì‹œì‘ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
    restartButton.addEventListener('click', () => {
      // ê²Œì„ ì˜¤ë²„ ì˜¤ë²„ë ˆì´ ìˆ¨ê¸°ê¸°
      gameOverScreen.style.display = 'none';

      // ê¸°ì¡´ ê²Œì„ ìƒíƒœë¥¼ ì´ˆê¸°í™” í›„ ë‹¤ì‹œ ì‹œì‘
      startGame();
    });
  </script>
</body>
</html>
